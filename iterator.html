<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stdgpu: Iterating over Arrays and Containers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="stdgpu_logo.ico">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-paragraph-link.js" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="stdgpu_logo.png"/></td>
  <td id="projectalign">
  <div id="projectname"><span id="projectnumber">&#160;Latest</span>
  </div>
   <!--<div id="projectbrief">Efficient STL-like Data Structures on the GPU</div>-->
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('iterator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Iterating over Arrays and Containers </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_runner_work_stdgpu_stdgpu_doc_stdgpu_iterator"></a></p>
<h1><a class="anchor" id="iterator_overview"></a>
Motivation</h1>
<p>The iterator concept is one of the core aspects of the Standard Template Library (STL). Most C++ programmers are familiar with this concept and can easily write algorithms with it. The thrust library aims to provide the STL functionality also for device arrays and vectors. This includes the convenient iterator syntax. Consider the following STL example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algortihm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;float&gt; vector(1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill it with something useful</span></div>
<div class="line"> </div>
<div class="line">std::sort(vector.begin(), vector.end());            <span class="comment">// C++98</span></div>
<div class="line">std::sort(std::begin(vector), std::end(vector));    <span class="comment">// C++11</span></div>
</div><!-- fragment --><p>In modern C++, the latter more recent version of begin and end should be used. Semantically, they are identical. thrust provides a similar syntax for its containers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thrust/device_vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thrust/sort.h&gt;</span></div>
<div class="line"> </div>
<div class="line">thrust::device_vector&lt;float&gt; device_vector(1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill it with something useful</span></div>
<div class="line"> </div>
<div class="line">thrust::sort(thrust::device, vector.begin(), vector.end());</div>
</div><!-- fragment --><p>The differences to the STL are mostly related to the more generic setting. Although thrust is able to automatically infer whether the vector is allocated on the host or device, it is advisable to clearly state that sorting should be done on the device.</p>
<p>It is also possible to pass raw pointers to thrust algorithms, but the syntax gets intrusive:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thrust/device_ptr.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thrust/sort.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span>* device_array = createDeviceArray&lt;float&gt;(1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill it with something useful</span></div>
<div class="line"> </div>
<div class="line">thrust::sort(thrust::device, thrust::device_pointer_cast(device_array), thrust::device_pointer_cast(device_array + 1000));</div>
<div class="line"> </div>
<div class="line">destroyDeviceArray&lt;float&gt;(device_array);</div>
<div class="ttc" id="amemory_8h_html"><div class="ttname"><a href="memory_8h.html">memory.h</a></div></div>
</div><!-- fragment --><p>The intent of casting to the thrust API is clear, but very verbose. Furthermore, the size of the array must be known and explicitly stated to compute the iterator pointing to the end of the array.</p>
<h1><a class="anchor" id="iterator_api"></a>
Iterator API</h1>
<p>Similar to what the <a class="el" href="memory.html">memory management API</a> provides, there is also an API to avoid boilerplate code such as in the example above. It can be considered as a natural extension to how thrust and STL perform in C++11:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thrust/sort.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="iterator_8h.html">stdgpu/iterator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span>* device_array = createDeviceArray&lt;float&gt;(1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill it with something useful</span></div>
<div class="line"> </div>
<div class="line">thrust::sort(<a class="code hl_function" href="group__iterator_ga6fb75645295f15b396cf74957f8de508.html#ga6fb75645295f15b396cf74957f8de508">stdgpu::device_begin</a>(device_array), <a class="code hl_function" href="group__iterator_ga7c9ac3d63e5edf4b233a2e9a81a71144.html#ga7c9ac3d63e5edf4b233a2e9a81a71144">stdgpu::device_end</a>(device_array));</div>
<div class="line"> </div>
<div class="line">destroyDeviceArray&lt;float&gt;(device_array);</div>
<div class="ttc" id="agroup__iterator_ga6fb75645295f15b396cf74957f8de508_html_ga6fb75645295f15b396cf74957f8de508"><div class="ttname"><a href="group__iterator_ga6fb75645295f15b396cf74957f8de508.html#ga6fb75645295f15b396cf74957f8de508">stdgpu::device_begin</a></div><div class="ttdeci">device_ptr&lt; T &gt; device_begin(T *device_array)</div><div class="ttdoc">Creates a pointer to the begin of the given device array.</div></div>
<div class="ttc" id="agroup__iterator_ga7c9ac3d63e5edf4b233a2e9a81a71144_html_ga7c9ac3d63e5edf4b233a2e9a81a71144"><div class="ttname"><a href="group__iterator_ga7c9ac3d63e5edf4b233a2e9a81a71144.html#ga7c9ac3d63e5edf4b233a2e9a81a71144">stdgpu::device_end</a></div><div class="ttdeci">device_ptr&lt; T &gt; device_end(T *device_array)</div><div class="ttdoc">Creates a pointer to the end of the given device array.</div></div>
<div class="ttc" id="aiterator_8h_html"><div class="ttname"><a href="iterator_8h.html">iterator.h</a></div></div>
</div><!-- fragment --><p>Compare this systax to the C++11 version of the STL call. This becomes possible by the internal leak check which now provides the required size information. Therefore, <a class="el" href="group__iterator_ga7c9ac3d63e5edf4b233a2e9a81a71144.html#ga7c9ac3d63e5edf4b233a2e9a81a71144" title="Creates a pointer to the end of the given device array.">stdgpu::device_end</a> can query the size of the given array and return a pointer to the end. Furthermore, the functions check whether the array is allocated on the host or device to avoid mismatches. Iterators are defined for both host and device arrays. In addition, the const versions of them are also defined. Consider the following C++14 STL example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algortihm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;float&gt; vector(1000);</div>
<div class="line">std::vector&lt;float&gt; vector_out(1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill it with something useful</span></div>
<div class="line"> </div>
<div class="line">std::transform(std::cbegin(vector), std::cend(vector), std::begin(vector_out), std::negate&lt;float&gt;());  <span class="comment">// C++14</span></div>
</div><!-- fragment --><p>The device version with the memory management API is almost identical:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thrust/transform.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thrust/functional.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="iterator_8h.html">stdgpu/iterator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span>* device_array     = createDeviceArray&lt;float&gt;(1000);</div>
<div class="line"><span class="keywordtype">float</span>* device_array_out = createDeviceArray&lt;float&gt;(1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill it with something useful</span></div>
<div class="line"> </div>
<div class="line">thrust::transform(<a class="code hl_function" href="group__iterator_ga483c639b2f3a2c8dd265a5ef22f73341.html#ga483c639b2f3a2c8dd265a5ef22f73341">stdgpu::device_cbegin</a>(device_array), <a class="code hl_function" href="group__iterator_ga5769e14b2700cfbfd14b408524a1a34f.html#ga5769e14b2700cfbfd14b408524a1a34f">stdgpu::device_cend</a>(device_array), <a class="code hl_function" href="group__iterator_ga6fb75645295f15b396cf74957f8de508.html#ga6fb75645295f15b396cf74957f8de508">stdgpu::device_begin</a>(device_array_out), thrust::negate&lt;float&gt;());</div>
<div class="line"> </div>
<div class="line">destroyDeviceArray&lt;float&gt;(device_array);</div>
<div class="line">destroyDeviceArray&lt;float&gt;(device_array_out);</div>
<div class="ttc" id="agroup__iterator_ga483c639b2f3a2c8dd265a5ef22f73341_html_ga483c639b2f3a2c8dd265a5ef22f73341"><div class="ttname"><a href="group__iterator_ga483c639b2f3a2c8dd265a5ef22f73341.html#ga483c639b2f3a2c8dd265a5ef22f73341">stdgpu::device_cbegin</a></div><div class="ttdeci">device_ptr&lt; const T &gt; device_cbegin(const T *device_array)</div><div class="ttdoc">Creates a constant pointer to the begin of the given device array.</div></div>
<div class="ttc" id="agroup__iterator_ga5769e14b2700cfbfd14b408524a1a34f_html_ga5769e14b2700cfbfd14b408524a1a34f"><div class="ttname"><a href="group__iterator_ga5769e14b2700cfbfd14b408524a1a34f.html#ga5769e14b2700cfbfd14b408524a1a34f">stdgpu::device_cend</a></div><div class="ttdeci">device_ptr&lt; const T &gt; device_cend(const T *device_array)</div><div class="ttdoc">Creates a constant pointer to the end of the given device array.</div></div>
</div><!-- fragment --><p>The combination of both the memory management and the iterator API provides a very powerful interface to interact with thrust as well as kernels in a fast, safe and intuitive way. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <!--<ul>
    <li class="navelem"><a class="el" href="chapters.html">Chapters</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>-->
</div>
</body>
</html>
